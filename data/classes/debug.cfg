//Debug assist functions.
{
	types: {
		AOTree: "{indent:int, key:any, value:any}|[{indent:int, key:any, value:any}]",
		AOTItem: "{indent:int, key:any, value:any}",
	},
	//Pretty-print function, useful on the console to dig into data structures containing objects.
	pp: "def(any val) debug(
		'\n\n==================\nBEGIN OUTPUT BLOCK\n==================\n\n' 
		+ _serialize_aot_item(_abstract_object_tree(val))
		)",
	
	_abstract_object_tree: "def(any val, int indent=0, map seen={}) -> {indent:int, key:any, value:any}|[{indent:int, key:any, value:any}]
	if(
		(not seen[val]) and (val is custom_obj or val is map or val is level),
		[{
			indent: indent, 
			key: key,
			value: _abstract_object_tree(val[key], indent+1, seen + {(val):true}),
		} | key <- sort(
			keys(custom_obj|map|level<-val), 
			def(a,b) a<b)
		],
		if(val is list and not seen[val], 
			map(val, {
				indent: indent,
				key: index,
				value: _abstract_object_tree(value, indent+1, seen + {(val):true}),
			}),
			{ //Not an iterable thing, we guess.
				indent: indent,
				key: null,
				value: val,
			}
		)
	)",
	
	_serialize_aot_item: "overload(
		def({indent:int, key:any, value:any} item) -> string
			if(item.key != null, 
				fold([' ']*4*item.indent, a+b) + str(item.key) + ': ', 
				'' ) 
			+ if(item.value is {indent: int, key: any, value: any},
				_serialize_aot_item(item.value),
				if(item.value is list,
					if(not size(item.value), 
						'[] (empty list)',
						'\n' + fold(map(
							item.value[0:({0:int(1/0), 1:10, 2: 2, 3:0}[item.indent])], //[
							fold([' ']*4*item.indent, a+b) + _serialize_aot_item({indent:int, key:any, value:any} <- value)
						), a+'\n'+b) + '' //]
					),
					str(item.value) + ' (str item)',
				),
			),
		def([{indent:int, key:any, value:any}] tree) -> string 
			fold([string]<-map(tree, _serialize_aot_item(value)), str(a)+'\n'+str(b))
	)",
	
	/* Add to above if line-trimming becomes needed.
	if(size(item_line) <= 80, 
		item_line, 
		item_line[0:79]+'â€¦'
	) where item_line = 'foo'
	*/
}