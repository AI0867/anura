//Debug assist functions.
{
	types: {
		AOTree: "{indent:int, key:any, value:any}|[{indent:int, key:any, value:any}]",
		AOTItem: "{indent:int, key:any, value:any}",
	},
	//short name for pretty_print, easier to type when debugging
	pp: "def(any val) -> commands
		debug(pretty_string(val))",
	
	//Pretty-print function, useful on the console to dig into data structures containing objects.
	pretty_print: "def(any val) -> commands
		debug(pretty_string(val))",
	
	//Prettily format a data structure for human consumption. Used for debugging by pretty_print/pp and by the engine for the debug console via the --console-prettyprint option.
	pretty_string: "def(any val) -> string
		if(size(output) > 400, 
			'\n\n==================\nOUTPUT BLOCK\n==================\n\n' + output + '\n', //Can't use string interpolation with the where-clause here.
			if('\n' in split(output, ''),
				'\n' + output + '\n',
				output
			)
		) where output = _serialize_aot_item(_abstract_object_tree(val))",
	
	_abstract_object_tree: "def(any val, int indent=0, map seen={}) -> {indent:int, key:any, value:any, type:string}|[{indent:int, key:any, value:any, type:string}]
	if(indent < max_tree_depth,
		if(
			(not seen[val]) and (val is custom_obj or val is map or val is level),
			[{
				indent: indent, 
				key: key,
				value: _abstract_object_tree(val[key], indent+1, seen + {(val):true}),
				type: typeof(val[key]),
			} | key <- if('type' in keys and 'animation' in keys and 'xy' in keys, 
					['type', 'animation', 'xy'] + keys, 
					keys
				) where keys = sort(keys(custom_obj|map|level<-val))
			],
			if(val is list and not seen[val], 
				map(val, {
					indent: indent,
					key: index,
					value: _abstract_object_tree(value, indent+1, seen + {(val):true}),
					type: typeof(value),
				}),
				if(not seen[val], 
					{ //Not an iterable thing, we guess.
						indent: indent,
						key: null,
						value: val,
						type: typeof(val),
					},
					{ // seen?
						indent: indent,
						key: null,
						value: typeof(val), //Use the type of the object as the value as a placeholder, since we've already printed it once and don't want to recurse what are effectively doubly-linked lists. (ie, level.player.level.player...)
						type: typeof(val),
					}
				)
			)
		),
		{
			indent: indent, 
			key: null,
			value: '<<<error: structure inspector max_tree_depth reached, can not look deeper - increase in the debug.cfg class>>>',
			type: 'null',
		}
	) where max_tree_depth = 5",
	
	_serialize_aot_item: "overload(
		def({indent:int, key:any, value:any, type:string} item) -> string
			if(item.key != null, 
				fold([' ']*4*item.indent, a+b) + _single_value_to_string(item.key) + ': ', 
				'' ) 
			+ if(item.value is {indent: int, key: any, value: any, type: string},
				_serialize_aot_item(item.value),
				if(item.value is list,
					//single-line int list view, covers Points.
					if(size(item.value) and size(item.value) <= 10 and item.value is [{indent: int, key: any, value: {indent: int, key: null, value: int, type: string}, type: string}], (
						//One-line lists/objects.
						item_brackets[0] + item_string + item_brackets[1]
							where
								item_string = fold(
									map(([{indent: int, key: any, value: {indent:int, key: any, value: decimal, type: string}, type: string}] <- item.value), 
										_single_value_to_string(value.value.value)), 
									a + ', ' + b),
								item_brackets = _type_to_brackets(item.type)
						),(
							if(not size(item.value), 
								//Empty list/object.
								item_brackets[0] + 'empty' + item_brackets[1],
								//Long lists/objects which are split over many lines.
								item_brackets[0]
								+ if(list_display_size,
									'\n' + fold(map(
										item.value[0:list_display_size], //Display less the deeper we are.
										_serialize_aot_item({indent:int, key:any, value:any, type:string} <- value)
									), a+'\n'+b)
									+ '\n'+ fold([' ']*4*item.indent, a+b),
									''
								)
								+ item_brackets[1]
								+ if(size(item.value) - list_display_size <= 0, 
									'', 
									' plus ' + str(size(item.value) - list_display_size) + ' more items'
								)
							) where
								list_display_size = ({0:10, 1:5, 2: 3, 3:0}[item.indent]),
								item_brackets = _type_to_brackets(item.type)
						)
					),
					_single_value_to_string(item.value),
				),
			),
		def([{indent:int, key:any, value:any, type:string, type:string}] tree) -> string 
			'\n' + fold([string]<-map(tree, _serialize_aot_item(value)), str(a)+'\n'+str(b)) + '\n'
	)",
	
	/* Add to above if line-trimming becomes needed.
	if(size(item_line) <= 80, 
		item_line, 
		item_line[0:79]+'â€¦'
	) where item_line = 'foo'
	*/
	
	_single_value_to_string: "def(any value) -> string
		if(value is string, q(')+value+q('), str(value))",
	
	_type_to_brackets: "def(string valtype) -> string
		switch(valtype[0], '[', '[]', '{}')",
	
}

//[1,[2,3],[4,5,6], [[7,8,9],[7,8,me],[7,8,9]], {9:10, 11:[12,13], 14:{15:16}}]